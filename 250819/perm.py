# 순열
# N개의 원소 중에서 R개를 뽑아서 순서 있게 나열하는 것

arr = [1, 2, 3, 4, 5]
N = len(arr)
R = 3

visited = [False] * N  # 해당 숫자가 사용되었는지 여부 저장
res = [0] * 3  # 출력 배열(뽑은 숫자를 순서대로 저장할 배열)

# 재귀함수의 설계
# - R개를 뽑아야 한다면, R개를 한번에 뽑는 것이 아니라,
#   1개만 뽑고, 나머지 R-1개는 그 다음 재귀호출에 넘긴다.
# - 한번에 하나만 처리하고, 나머지는 그다음 재귀 호출에서 처리
# - ex) 0번 위치 하나만 뽑고, 나머지(1, 2, .., R-1)는 그다음 재귀 함수가 처리
# - ...
# - ex) n번 위치 하나를 뽑았다면, 나머지는(n+1 ~, R-1) 그 다음 재귀 함수가 처리


# 재귀함수
# - 구조: 두 가지 파트로 나뉨
# - 1. 기저조건(base case): 재귀함수가 끝나는 조건, 더이상 자기자신을 호출하지 않는 조건
# - 2. 유도조건: 자기자신을 호출하는 경우


def perm(idx):
    # print(f"perm({idx}) start")
    # 1. 기저조건
    if idx == R:  # 기저조건
        # 재귀호출 하지 않음
        print(res)
        return  # 함수를 종료
    # 그 다음을 호출한다.

    # 2. 유도조건
    # 아직 뽑지 않은 숫자 중에서 숫자를 뽑고, 그 다음 숫자를 뽑으러 가야 함
    for i in range(N):
        if not visited[i]:  # 5개 숫자 중에서 i번째를 뽑지 않았다면
            visited[i] = True  # i번째 숫자를 뽑는다
            res[idx] = arr[i]  # i번째 숫자를 idx번째
            perm(idx + 1)  # 그다음 자리 수 뽑으러 가기
            visited[i] = False  # 방문처리 초기화

    # print(f"perm({idx}) end")


# N개의 원소 중에서
# 0, 1, .., R-1까지 뽑아야 함
perm(0)  # 0번 위치 하나만 뽑고, perm(1) 호출
